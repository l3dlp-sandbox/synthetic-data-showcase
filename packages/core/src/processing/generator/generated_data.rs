use csv::WriterBuilder;
use log::info;

#[cfg(feature = "pyo3")]
use pyo3::prelude::*;

#[cfg(feature = "pyo3")]
use crate::data_block::typedefs::CsvRecord;

use crate::{
    data_block::{csv_io_error::CsvIOError, typedefs::RawSyntheticData},
    utils::time::ElapsedDurationLogger,
};

#[cfg_attr(feature = "pyo3", pyclass)]
/// Synthetic data generated by the Generator
pub struct GeneratedData {
    /// Synthesized data - headers (index 0) and records indexes 1...
    pub synthetic_data: RawSyntheticData,
    /// `Synthetic data length / Sensitive data length` (header not included)
    pub expansion_ratio: f64,
}

impl GeneratedData {
    /// Returns a new GeneratedData struct with default values
    #[inline]
    pub fn default() -> GeneratedData {
        GeneratedData {
            synthetic_data: RawSyntheticData::default(),
            expansion_ratio: 0.0,
        }
    }

    /// Returns a new GeneratedData struct
    /// # Arguments
    /// * `synthetic_data` - Synthesized data - headers (index 0) and records indexes 1...
    /// * `expansion_ratio` - `Synthetic data length / Sensitive data length` (header not included)
    #[inline]
    pub fn new(synthetic_data: RawSyntheticData, expansion_ratio: f64) -> GeneratedData {
        GeneratedData {
            synthetic_data,
            expansion_ratio,
        }
    }
}

#[cfg_attr(feature = "pyo3", pymethods)]
impl GeneratedData {
    #[cfg(feature = "pyo3")]
    /// Synthesized data - headers (index 0) and records indexes 1...
    /// This method will clone the data, so its recommended to have its result stored
    /// in a local variable to avoid it being called multiple times
    fn get_synthetic_data(&self) -> Vec<CsvRecord> {
        self.synthetic_data
            .iter()
            .map(|row| row.iter().map(|value| (**value).clone()).collect())
            .collect()
    }

    #[cfg(feature = "pyo3")]
    #[getter]
    /// `Synthetic data length / Sensitive data length` (header not included)
    fn expansion_ratio(&self) -> f64 {
        self.expansion_ratio
    }

    /// Writes the synthesized data to the file system
    /// # Arguments
    /// * `path` - File path to be written
    /// * `delimiter` - Delimiter to use when writing to `path`
    pub fn write_synthetic_data(&self, path: &str, delimiter: char) -> Result<(), CsvIOError> {
        let _duration_logger = ElapsedDurationLogger::new("write synthetic data");

        info!("writing file {}", path);

        let mut wtr = match WriterBuilder::new()
            .delimiter(delimiter as u8)
            .from_path(&path)
        {
            Ok(writer) => writer,
            Err(err) => return Err(CsvIOError::new(err)),
        };

        // write header and records
        for r in self.synthetic_data.iter() {
            match wtr.write_record(r.iter().map(|v| v.as_str())) {
                Ok(_) => {}
                Err(err) => return Err(CsvIOError::new(err)),
            };
        }
        Ok(())
    }

    /// Generates a CSV string from the synthetic data
    /// # Arguments
    /// * `delimiter` - CSV delimiter to use
    pub fn synthetic_data_to_csv(&self, delimiter: char) -> String {
        let mut csv_data = String::default();

        for (row_index, row) in self.synthetic_data.iter().enumerate() {
            for (column_index, value) in row.iter().enumerate() {
                csv_data.push_str(value);
                if column_index != (row.len() - 1) {
                    csv_data.push(delimiter);
                }
            }
            if row_index != (self.synthetic_data.len() - 1) {
                csv_data.push('\n');
            }
        }
        csv_data
    }
}
