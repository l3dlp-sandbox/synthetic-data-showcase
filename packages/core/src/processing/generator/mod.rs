/// Module defining the data synthesis process
pub mod synthesizer;

use csv::{Error, WriterBuilder};
use log::Level::Trace;
use log::{info, log_enabled, trace};
use std::time::Duration;

use crate::data_block::block::DataBlock;
use crate::data_block::typedefs::CsvRecordRef;
use crate::measure_time;
use crate::processing::generator::synthesizer::cache::SynthesizerCacheKey;
use crate::processing::generator::synthesizer::seeded::SeededSynthesizer;
use crate::utils::reporting::ReportProgress;
use crate::utils::time::ElapsedDuration;

use self::synthesizer::typedefs::SynthesizedRecords;

#[derive(Debug)]
struct GeneratorDurations {
    generate: Duration,
    write_records: Duration,
}

/// Process a data block and generates new synthetic data
pub struct Generator<'data_block> {
    data_block: &'data_block DataBlock,
    durations: GeneratorDurations,
}

/// Synthetic data generated by the Generator
pub struct GeneratedData<'data_block> {
    /// Synthesized data - headers (index 0) and records indexes 1...
    pub synthetic_data: Vec<CsvRecordRef<'data_block>>,
    /// `Synthetic data length / Sensitive data length` (header not included)
    pub expansion_ratio: f64,
}

impl<'data_block> Generator<'data_block> {
    /// Returns a new Generator
    /// # Arguments
    /// * `data_block` - Sensitive data to be synthesized
    #[inline]
    pub fn new(data_block: &'data_block DataBlock) -> Generator<'data_block> {
        Generator {
            data_block,
            durations: GeneratorDurations {
                generate: Duration::default(),
                write_records: Duration::default(),
            },
        }
    }

    /// Generates new synthetic data based on sensitive data
    /// # Arguments
    /// * `resolution` - Reporting resolution used for data synthesis
    /// * `cache_max_size` - Maximum cache size allowed
    /// * `empty_value` - Empty values on the synthetic data will be represented by this
    /// * `progress_reporter` - Will be used to report the processing
    /// progress (`ReportProgress` trait). If `None`, nothing will be reported
    pub fn generate<T>(
        &mut self,
        resolution: usize,
        cache_max_size: usize,
        empty_value: &'data_block str,
        progress_reporter: &mut Option<T>,
    ) -> GeneratedData<'data_block>
    where
        T: ReportProgress,
    {
        info!("starting generation...");

        measure_time!(
            || {
                let mut result: Vec<CsvRecordRef<'data_block>> = Vec::default();
                let mut records: Vec<CsvRecordRef<'data_block>> = self
                    .seeded_synthesis(resolution, cache_max_size, progress_reporter)
                    .iter()
                    .map(|r| {
                        SynthesizerCacheKey::new(self.data_block.headers.len(), r)
                            .format_record(empty_value)
                    })
                    .collect();

                // sort by number of defined attributes
                records.sort();
                records.sort_by_key(|r| {
                    -r.iter()
                        .map(|s| if s.is_empty() { 0 } else { 1 })
                        .sum::<isize>()
                });

                let expansion_ratio = records.len() as f64 / self.data_block.records.len() as f64;

                info!("expansion ratio: {:.4?}", expansion_ratio);

                result.push(self.data_block.headers.iter().map(|h| h.as_str()).collect());
                result.extend(records);

                GeneratedData {
                    synthetic_data: result,
                    expansion_ratio,
                }
            },
            (self.durations.generate)
        )
    }

    /// Writes the synthesized data to the file system
    /// # Arguments
    /// * `result` - Synthetic data to write (headers included)
    /// * `path` - File path to be written
    /// * `delimiter` - Delimiter to use when writing to `path`
    pub fn write_records(
        &mut self,
        result: &[CsvRecordRef<'data_block>],
        path: &str,
        delimiter: u8,
    ) -> Result<(), Error> {
        info!("writing file {}", path);

        measure_time!(
            || {
                let mut wtr = WriterBuilder::new().delimiter(delimiter).from_path(&path)?;

                // write header and records
                for r in result.iter() {
                    wtr.write_record(r)?;
                }
                Ok(())
            },
            (self.durations.write_records)
        )
    }

    fn seeded_synthesis<T>(
        &mut self,
        resolution: usize,
        cache_max_size: usize,
        progress_reporter: &mut Option<T>,
    ) -> SynthesizedRecords<'data_block>
    where
        T: ReportProgress,
    {
        let attr_rows_map = DataBlock::calc_attr_rows(&self.data_block.records);
        let mut synth =
            SeededSynthesizer::new(self.data_block, &attr_rows_map, resolution, cache_max_size);
        synth.run(progress_reporter)
    }
}

impl<'data_block> Drop for Generator<'data_block> {
    fn drop(&mut self) {
        trace!("generator durations: {:#?}", self.durations);
    }
}
